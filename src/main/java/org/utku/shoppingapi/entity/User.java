package org.utku.shoppingapi.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.utku.shoppingapi.constants.AppConstants;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * JPA Entity representing a user account in the e-commerce shopping system.
 * 
 * <p>This entity encapsulates all user-related information and serves as the
 * central point for user management in the application. It includes authentication
 * credentials, personal information, account settings, and relationships with
 * other entities in the system.
 * 
 * <p>Key features:
 * <ul>
 *   <li>Unique username and email constraints for account identification</li>
 *   <li>Role-based access control through user roles</li>
 *   <li>One-to-one relationship with shopping cart</li>
 *   <li>One-to-many relationship with favorite products</li>
 *   <li>Automatic timestamp management for audit trails</li>
 *   <li>Account enable/disable functionality</li>
 * </ul>
 * 
 * <p>Database mapping:
 * <ul>
 *   <li>Table name: "users"</li>
 *   <li>Primary key: Auto-generated Long ID</li>
 *   <li>Unique constraints: username, email</li>
 *   <li>Related tables: user_roles, carts, favorites</li>
 * </ul>
 * 
 * <p>Validation constraints are applied using Bean Validation annotations
 * to ensure data integrity and business rule compliance.
 * 
 * @author Shopping API Development Team
 * @version 1.0
 * @since 1.0
 * @see Cart
 * @see Favorite
 * @see Role
 * @see AppConstants
 */
@Entity
@Table(name = "users",
        uniqueConstraints = {
                @UniqueConstraint(columnNames = "username"),
                @UniqueConstraint(columnNames = "email")
        })
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    /**
     * The unique identifier for this user entity.
     * 
     * <p>This field serves as the primary key for the user table and is
     * automatically generated by the database using an identity column.
     * The value is assigned when the entity is first persisted and
     * remains immutable throughout the entity's lifecycle.
     * 
     * @see GenerationType#IDENTITY
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The unique username for this user account.
     * 
     * <p>This field serves as one of the primary identifiers for user authentication
     * and must be unique across the entire system. The username is used for login
     * purposes and public identification within the application.
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Cannot be null or blank</li>
     *   <li>Must be unique across all users</li>
     *   <li>Length must be between MIN_USERNAME_LENGTH and MAX_USERNAME_LENGTH</li>
     *   <li>Database column length is limited to MAX_USERNAME_LENGTH</li>
     * </ul>
     * 
     * @see AppConstants#MIN_USERNAME_LENGTH
     * @see AppConstants#MAX_USERNAME_LENGTH
     */
    @Column(nullable = false, unique = true, length = AppConstants.MAX_USERNAME_LENGTH)
    @NotBlank(message = "Username cannot be empty")
    @Size(min = AppConstants.MIN_USERNAME_LENGTH, max = AppConstants.MAX_USERNAME_LENGTH, 
          message = "Username must be between " + AppConstants.MIN_USERNAME_LENGTH + 
                   "-" + AppConstants.MAX_USERNAME_LENGTH + " characters")
    private String username;

    /**
     * The email address associated with this user account.
     * 
     * <p>This field serves as both a unique identifier and communication channel
     * for the user. It is used for account verification, password recovery,
     * and system notifications.
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Cannot be null or blank</li>
     *   <li>Must be unique across all users</li>
     *   <li>Must conform to valid email format (RFC 5322)</li>
     *   <li>Database column length is limited to MAX_EMAIL_LENGTH</li>
     * </ul>
     * 
     * @see AppConstants#MAX_EMAIL_LENGTH
     */
    @Column(nullable = false, unique = true, length = AppConstants.MAX_EMAIL_LENGTH)
    @NotBlank(message = "Email address cannot be empty")
    @Email(message = "Please enter a valid email address")
    private String email;

    /**
     * The encrypted password for user authentication.
     * 
     * <p>This field stores the user's password in encrypted form for security.
     * The password should be hashed using a strong cryptographic algorithm
     * before being stored in this field.
     * 
     * <p>Security considerations:
     * <ul>
     *   <li>Never store passwords in plain text</li>
     *   <li>Use strong hashing algorithms (e.g., BCrypt, Argon2)</li>
     *   <li>Implement proper salt generation</li>
     *   <li>Consider password complexity requirements</li>
     * </ul>
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Cannot be null or blank</li>
     *   <li>Minimum length requirement for basic security</li>
     * </ul>
     * 
     * @see AppConstants#MIN_PASSWORD_LENGTH
     */
    @Column(nullable = false)
    @NotBlank(message = "Password cannot be empty")
    @Size(min = AppConstants.MIN_PASSWORD_LENGTH, 
          message = "Password must be at least " + AppConstants.MIN_PASSWORD_LENGTH + " characters")
    private String password;

    /**
     * The user's first name (optional).
     * 
     * <p>This field stores the user's given name for personalization
     * and display purposes. It is optional and can be null.
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Optional field (can be null)</li>
     *   <li>Maximum length limited by MAX_NAME_LENGTH</li>
     *   <li>Used in combination with lastName for full name display</li>
     * </ul>
     * 
     * @see #getFullName()
     * @see AppConstants#MAX_NAME_LENGTH
     */
    @Column(length = AppConstants.MAX_NAME_LENGTH)
    @Size(max = AppConstants.MAX_NAME_LENGTH, 
          message = "First name cannot exceed " + AppConstants.MAX_NAME_LENGTH + " characters")
    private String firstName;

    /**
     * The user's last name (optional).
     * 
     * <p>This field stores the user's family name for personalization
     * and display purposes. It is optional and can be null.
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Optional field (can be null)</li>
     *   <li>Maximum length limited by MAX_NAME_LENGTH</li>
     *   <li>Used in combination with firstName for full name display</li>
     * </ul>
     * 
     * @see #getFullName()
     * @see AppConstants#MAX_NAME_LENGTH
     */
    @Column(length = AppConstants.MAX_NAME_LENGTH)
    @Size(max = AppConstants.MAX_NAME_LENGTH, 
          message = "Last name cannot exceed " + AppConstants.MAX_NAME_LENGTH + " characters")
    private String lastName;

    /**
     * The user's contact phone number (optional).
     * 
     * <p>This field stores the user's phone number for contact purposes,
     * order notifications, and account verification. The format is flexible
     * to accommodate international phone number formats.
     * 
     * <p>Constraints:
     * <ul>
     *   <li>Optional field (can be null)</li>
     *   <li>Maximum length limited by MAX_PHONE_LENGTH</li>
     *   <li>No format validation applied (flexible international support)</li>
     * </ul>
     * 
     * @see AppConstants#MAX_PHONE_LENGTH
     */
    @Column(length = AppConstants.MAX_PHONE_LENGTH)
    private String phoneNumber;

    /**
     * Flag indicating whether the user account is enabled and active.
     * 
     * <p>This field controls account accessibility and functionality:
     * <ul>
     *   <li>true: Account is active and fully functional</li>
     *   <li>false: Account is disabled and cannot be used for login or operations</li>
     * </ul>
     * 
     * <p>Use cases for disabled accounts:
     * <ul>
     *   <li>Temporary account suspension</li>
     *   <li>GDPR-compliant account anonymization</li>
     *   <li>Administrative account management</li>
     *   <li>Account verification pending</li>
     * </ul>
     * 
     * <p>Default value is true for new accounts.
     */
    @Column(nullable = false)
    private Boolean enabled = true;

    /**
     * Timestamp indicating when this user account was created.
     * 
     * <p>This field is automatically populated by Hibernate when the entity
     * is first persisted to the database. It provides an audit trail for
     * account creation and is never updated after initial creation.
     * 
     * <p>Features:
     * <ul>
     *   <li>Automatically set on entity creation</li>
     *   <li>Immutable after creation (updatable = false)</li>
     *   <li>Used for audit trails and analytics</li>
     *   <li>Stored in 'created_at' database column</li>
     * </ul>
     * 
     * @see CreationTimestamp
     */
    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    /**
     * Timestamp indicating when this user account was last modified.
     * 
     * <p>This field is automatically updated by Hibernate whenever any
     * field in the entity is modified and the entity is saved. It provides
     * an audit trail for tracking account changes.
     * 
     * <p>Features:
     * <ul>
     *   <li>Automatically updated on any entity modification</li>
     *   <li>Updated on every save operation</li>
     *   <li>Used for audit trails and change tracking</li>
     *   <li>Stored in 'updated_at' database column</li>
     * </ul>
     * 
     * @see UpdateTimestamp
     */
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    /**
     * Set of roles assigned to this user for access control.
     * 
     * <p>This field implements role-based access control (RBAC) by storing
     * a collection of roles that determine what operations the user can perform
     * within the system.
     * 
     * <p>Implementation details:
     * <ul>
     *   <li>Stored as enum values in separate 'user_roles' table</li>
     *   <li>Eagerly fetched for performance in authorization checks</li>
     *   <li>Uses Set to prevent duplicate roles</li>
     *   <li>Initialized as empty HashSet by default</li>
     * </ul>
     * 
     * <p>Common roles might include: USER, ADMIN, MODERATOR, etc.
     * 
     * @see Role
     * @see #hasRole(Role)
     * @see #addRole(Role)
     * @see #removeRole(Role)
     */
    @Enumerated(EnumType.STRING)
    @ElementCollection(targetClass = Role.class, fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    private Set<Role> roles = new HashSet<>();

    /**
     * The shopping cart associated with this user account.
     * 
     * <p>This field establishes a one-to-one relationship between the user
     * and their shopping cart. Each user has exactly one cart that persists
     * across sessions to maintain shopping state.
     * 
     * <p>Relationship characteristics:
     * <ul>
     *   <li>One-to-one bidirectional relationship</li>
     *   <li>Lazily loaded for performance optimization</li>
     *   <li>Cascade ALL operations (create, update, delete)</li>
     *   <li>Cart is owned by the user (mappedBy = "user")</li>
     * </ul>
     * 
     * <p>The cart is automatically created when needed and persists
     * until the user account is deleted.
     * 
     * @see Cart
     */
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Cart cart;

    /**
     * Collection of favorite products associated with this user.
     * 
     * <p>This field maintains a list of products that the user has marked
     * as favorites for quick access and future reference. The relationship
     * supports full lifecycle management of favorite items.
     * 
     * <p>Relationship characteristics:
     * <ul>
     *   <li>One-to-many bidirectional relationship</li>
     *   <li>Lazily loaded for performance optimization</li>
     *   <li>Cascade ALL operations to child entities</li>
     *   <li>Orphan removal enabled for automatic cleanup</li>
     *   <li>Initialized as empty ArrayList by default</li>
     * </ul>
     * 
     * <p>When a user is deleted, all associated favorite records are
     * automatically removed from the database.
     * 
     * @see Favorite
     */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private List<Favorite> favorites = new ArrayList<>();

    /**
     * Constructs and returns the user's full name from available name components.
     * 
     * <p>This method intelligently combines the user's first and last names
     * to create a display-friendly full name. It handles various scenarios
     * where name components might be missing.
     * 
     * <p>Name construction logic:
     * <ol>
     *   <li>If both firstName and lastName are present: "FirstName LastName"</li>
     *   <li>If only firstName is present: "FirstName"</li>
     *   <li>If only lastName is present: "LastName"</li>
     *   <li>If neither name is present: returns username as fallback</li>
     * </ol>
     * 
     * <p>This method is commonly used in UI components, email templates,
     * and anywhere a human-readable name representation is needed.
     * 
     * @return A non-null string representing the user's full name,
     *         or username if no name components are available
     */
    public String getFullName() {
        if (firstName != null && lastName != null) {
            return firstName + " " + lastName;
        } else if (firstName != null) {
            return firstName;
        } else if (lastName != null) {
            return lastName;
        }
        return username;
    }

    /**
     * Determines whether this user has been assigned a specific role.
     * 
     * <p>This method is used for authorization checks throughout the application
     * to determine if a user has permission to perform certain operations.
     * It provides a convenient way to implement role-based access control.
     * 
     * <p>Usage examples:
     * <pre>
     * if (user.hasRole(Role.ADMIN)) {
     *     // Allow administrative operations
     * }
     * 
     * if (user.hasRole(Role.USER)) {
     *     // Allow standard user operations
     * }
     * </pre>
     * 
     * @param role The role to check for. Must not be null.
     * @return true if the user has the specified role, false otherwise
     * @throws NullPointerException if role parameter is null
     * @see Role
     */
    public boolean hasRole(Role role) {
        return roles.contains(role);
    }

    /**
     * Grants a specific role to this user.
     * 
     * <p>This method adds a new role to the user's role collection, effectively
     * granting them the permissions associated with that role. If the user
     * already has the role, this operation has no effect due to Set semantics.
     * 
     * <p>The role assignment takes effect immediately but requires the entity
     * to be saved to persist the change to the database.
     * 
     * <p>Usage example:
     * <pre>
     * user.addRole(Role.ADMIN);
     * userRepository.save(user); // Persist the change
     * </pre>
     * 
     * @param role The role to grant to this user. Must not be null.
     * @throws NullPointerException if role parameter is null
     * @see Role
     * @see #hasRole(Role)
     */
    public void addRole(Role role) {
        this.roles.add(role);
    }

    /**
     * Revokes a specific role from this user.
     * 
     * <p>This method removes a role from the user's role collection, effectively
     * revoking the permissions associated with that role. If the user doesn't
     * have the role, this operation has no effect.
     * 
     * <p>The role revocation takes effect immediately but requires the entity
     * to be saved to persist the change to the database.
     * 
     * <p>Usage example:
     * <pre>
     * user.removeRole(Role.ADMIN);
     * userRepository.save(user); // Persist the change
     * </pre>
     * 
     * <p>Caution: Removing roles may affect user's ability to access
     * certain features or perform specific operations.
     * 
     * @param role The role to revoke from this user. Must not be null.
     * @throws NullPointerException if role parameter is null
     * @see Role
     * @see #hasRole(Role)
     */
    public void removeRole(Role role) {
        this.roles.remove(role);
    }

}